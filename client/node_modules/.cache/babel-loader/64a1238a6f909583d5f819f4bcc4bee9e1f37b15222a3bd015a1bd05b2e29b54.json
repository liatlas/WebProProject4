{"ast":null,"code":"/**\n * Generate a shuffled puzzle board\n * @param {number} size - Board size (3, 4, 6, 8, or 10)\n * @param {number} moves - Number of random moves to make\n * @returns {Array} Shuffled board state\n */\nexport function generatePuzzle(size, moves = 100) {\n  const totalTiles = size * size;\n  let board = Array.from({\n    length: totalTiles\n  }, (_, i) => i);\n  let emptyIndex = totalTiles - 1;\n\n  // Make random valid moves to shuffle\n  for (let i = 0; i < moves; i++) {\n    const validMoves = getValidMoves(board, emptyIndex, size);\n    const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];\n\n    // Swap\n    [board[emptyIndex], board[randomMove]] = [board[randomMove], board[emptyIndex]];\n    emptyIndex = randomMove;\n  }\n  return board;\n}\n\n/**\n * Get valid moves for current board state\n * @param {Array} board - Current board state\n * @param {number} emptyIndex - Index of empty tile\n * @param {number} size - Board size\n * @returns {Array} Array of valid move indices\n */\nexport function getValidMoves(board, emptyIndex, size) {\n  const moves = [];\n  const row = Math.floor(emptyIndex / size);\n  const col = emptyIndex % size;\n\n  // Up\n  if (row > 0) moves.push(emptyIndex - size);\n  // Down\n  if (row < size - 1) moves.push(emptyIndex + size);\n  // Left\n  if (col > 0) moves.push(emptyIndex - 1);\n  // Right\n  if (col < size - 1) moves.push(emptyIndex + 1);\n  return moves;\n}\n\n/**\n * Check if a tile can be moved\n * @param {Array} board - Current board state\n * @param {number} tileIndex - Index of tile to move\n * @param {number} size - Board size\n * @returns {boolean}\n */\nexport function canMoveTile(board, tileIndex, size) {\n  const emptyIndex = board.indexOf(0);\n  const validMoves = getValidMoves(board, emptyIndex, size);\n  return validMoves.includes(tileIndex);\n}\n\n/**\n * Move a tile\n * @param {Array} board - Current board state\n * @param {number} tileIndex - Index of tile to move\n * @returns {Array|null} New board state or null if invalid move\n */\nexport function moveTile(board, tileIndex) {\n  const emptyIndex = board.indexOf(0);\n  const size = Math.sqrt(board.length);\n\n  // Check if move is valid (tiles must be adjacent)\n  const validMoves = getValidMoves(board, emptyIndex, size);\n  if (!validMoves.includes(tileIndex)) {\n    return null;\n  }\n\n  // Create new board and swap\n  const newBoard = [...board];\n  [newBoard[emptyIndex], newBoard[tileIndex]] = [newBoard[tileIndex], newBoard[emptyIndex]];\n  return newBoard;\n}\n\n/**\n * Get direction of move\n * @param {number} fromIndex - Starting index\n * @param {number} toIndex - Ending index\n * @param {number} size - Board size\n * @returns {string} Direction ('up', 'down', 'left', 'right')\n */\nexport function getMoveDirection(fromIndex, toIndex, size) {\n  const diff = toIndex - fromIndex;\n  if (diff === -size) return \"up\";\n  if (diff === size) return \"down\";\n  if (diff === -1) return \"left\";\n  if (diff === 1) return \"right\";\n  return \"unknown\";\n}\n\n/**\n * Check if puzzle is solved\n * @param {Array} board - Current board state\n * @returns {boolean}\n */\nexport function isSolved(board) {\n  for (let i = 0; i < board.length - 1; i++) {\n    if (board[i] !== i) return false;\n  }\n  return board[board.length - 1] === 0;\n}\n\n/**\n * Count inversions for solvability check\n * @param {Array} board - Board state\n * @returns {number} Number of inversions\n */\nexport function countInversions(board) {\n  let inversions = 0;\n  const filteredBoard = board.filter(tile => tile !== 0);\n  for (let i = 0; i < filteredBoard.length - 1; i++) {\n    for (let j = i + 1; j < filteredBoard.length; j++) {\n      if (filteredBoard[i] > filteredBoard[j]) {\n        inversions++;\n      }\n    }\n  }\n  return inversions;\n}\n\n/**\n * Check if puzzle is solvable\n * @param {Array} board - Board state\n * @param {number} size - Board size\n * @returns {boolean}\n */\nexport function isSolvable(board, size) {\n  const inversions = countInversions(board);\n  const emptyRow = Math.floor(board.indexOf(0) / size);\n  if (size % 2 === 1) {\n    // Odd grid: solvable if inversions is even\n    return inversions % 2 === 0;\n  } else {\n    // Even grid: solvable if (inversions + empty row from bottom) is odd\n    const emptyRowFromBottom = size - emptyRow;\n    return (inversions + emptyRowFromBottom) % 2 === 1;\n  }\n}\n\n/**\n * Generate a guaranteed solvable puzzle\n * @param {number} size - Board size\n * @returns {Array} Solvable board state\n */\nexport function generateSolvablePuzzle(size) {\n  let board;\n  let attempts = 0;\n  const maxAttempts = 100;\n  do {\n    board = generatePuzzle(size, size * size * 2);\n    attempts++;\n    if (attempts >= maxAttempts) {\n      // Fallback: create solved puzzle and make one legal move\n      board = Array.from({\n        length: size * size\n      }, (_, i) => i);\n      const emptyIndex = size * size - 1;\n      const validMoves = getValidMoves(board, emptyIndex, size);\n      const move = validMoves[0];\n      [board[emptyIndex], board[move]] = [board[move], board[emptyIndex]];\n      break;\n    }\n  } while (!isSolvable(board, size) || isSolved(board));\n  return board;\n}\n\n/**\n * Calculate minimum moves to solve (estimation using Manhattan distance)\n * @param {Array} board - Current board state\n * @param {number} size - Board size\n * @returns {number} Estimated minimum moves\n */\nexport function calculateMinimumMoves(board, size) {\n  let distance = 0;\n  for (let i = 0; i < board.length; i++) {\n    const tile = board[i];\n    if (tile === 0) continue;\n    const currentRow = Math.floor(i / size);\n    const currentCol = i % size;\n    const targetRow = Math.floor(tile / size);\n    const targetCol = tile % size;\n\n    // Manhattan distance\n    distance += Math.abs(currentRow - targetRow) + Math.abs(currentCol - targetCol);\n  }\n  return distance;\n}\n\n/**\n * Get difficulty rating based on moves required\n * @param {number} minimumMoves - Minimum moves to solve\n * @param {number} size - Board size\n * @returns {string} Difficulty rating\n */\nexport function getDifficultyRating(minimumMoves, size) {\n  const threshold = size * size;\n  if (minimumMoves < threshold * 0.5) return \"easy\";\n  if (minimumMoves < threshold * 1) return \"medium\";\n  if (minimumMoves < threshold * 1.5) return \"hard\";\n  return \"expert\";\n}\n\n/**\n * Get hint for next move\n * @param {Array} board - Current board state\n * @param {number} size - Board size\n * @returns {number|null} Index of tile to move, or null\n */\nexport function getHint(board, size) {\n  const emptyIndex = board.indexOf(0);\n  const validMoves = getValidMoves(board, emptyIndex, size);\n\n  // Find move that reduces Manhattan distance the most\n  let bestMove = null;\n  let bestScore = Infinity;\n  for (const moveIndex of validMoves) {\n    const testBoard = moveTile(board, moveIndex);\n    if (!testBoard) continue;\n    const score = calculateMinimumMoves(testBoard, size);\n    if (score < bestScore) {\n      bestScore = score;\n      bestMove = moveIndex;\n    }\n  }\n  return bestMove;\n}\n\n/**\n * Check if current solution is optimal\n * @param {number} moveCount - Number of moves taken\n * @param {number} minimumMoves - Minimum possible moves\n * @returns {boolean}\n */\nexport function isPerfectGame(moveCount, minimumMoves) {\n  // Allow small margin for error since minimum is an estimate\n  return moveCount <= minimumMoves * 1.1;\n}\n\n/**\n * Convert board to image slice positions\n * @param {Array} board - Board state\n * @param {number} size - Board size\n * @returns {Array} Array of {x, y, tile} for rendering\n */\nexport function boardToImageSlices(board, size) {\n  return board.map((tile, index) => {\n    const row = Math.floor(index / size);\n    const col = index % size;\n    return {\n      tile,\n      x: col,\n      y: row,\n      isEmpty: tile === 0\n    };\n  });\n}\n\n/**\n * Get tile's target position\n * @param {number} tile - Tile number\n * @param {number} size - Board size\n * @returns {object} {row, col}\n */\nexport function getTileTarget(tile, size) {\n  return {\n    row: Math.floor(tile / size),\n    col: tile % size\n  };\n}\n\n/**\n * Check if tile is in correct position\n * @param {number} tile - Tile number\n * @param {number} currentIndex - Current position\n * @returns {boolean}\n */\nexport function isTileInPlace(tile, currentIndex) {\n  return tile === currentIndex || tile === 0;\n}\n\n/**\n * Shuffle array using Fisher-Yates algorithm\n * @param {Array} array - Array to shuffle\n * @returns {Array} Shuffled array\n */\nexport function shuffleArray(array) {\n  const shuffled = [...array];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  return shuffled;\n}\n\n/**\n * Create solved board\n * @param {number} size - Board size\n * @returns {Array} Solved board state\n */\nexport function createSolvedBoard(size) {\n  return Array.from({\n    length: size * size\n  }, (_, i) => i);\n}\n\n/**\n * Clone board\n * @param {Array} board - Board to clone\n * @returns {Array} Cloned board\n */\nexport function cloneBoard(board) {\n  return [...board];\n}\n\n/**\n * Compare two boards\n * @param {Array} board1 - First board\n * @param {Array} board2 - Second board\n * @returns {boolean} True if boards are equal\n */\nexport function boardsEqual(board1, board2) {\n  if (board1.length !== board2.length) return false;\n  for (let i = 0; i < board1.length; i++) {\n    if (board1[i] !== board2[i]) return false;\n  }\n  return true;\n}\n\n/**\n * Get adjacent tiles to a position\n * @param {number} index - Tile index\n * @param {number} size - Board size\n * @returns {Array} Array of adjacent indices\n */\nexport function getAdjacentTiles(index, size) {\n  const row = Math.floor(index / size);\n  const col = index % size;\n  const adjacent = [];\n  if (row > 0) adjacent.push(index - size); // Up\n  if (row < size - 1) adjacent.push(index + size); // Down\n  if (col > 0) adjacent.push(index - 1); // Left\n  if (col < size - 1) adjacent.push(index + 1); // Right\n\n  return adjacent;\n}\n\n/**\n * Calculate progress percentage\n * @param {Array} board - Current board\n * @returns {number} Percentage solved (0-100)\n */\nexport function calculateProgress(board) {\n  let correctTiles = 0;\n  for (let i = 0; i < board.length - 1; i++) {\n    if (board[i] === i) correctTiles++;\n  }\n  return Math.round(correctTiles / (board.length - 1) * 100);\n}\n\n/**\n * Get all corner tiles\n * @param {number} size - Board size\n * @returns {Array} Array of corner tile indices\n */\nexport function getCornerTiles(size) {\n  return [0,\n  // Top-left\n  size - 1,\n  // Top-right\n  size * (size - 1),\n  // Bottom-left\n  size * size - 1 // Bottom-right (empty space)\n  ];\n}\n\n/**\n * Get all edge tiles (not corners)\n * @param {number} size - Board size\n * @returns {Array} Array of edge tile indices\n */\nexport function getEdgeTiles(size) {\n  const edges = [];\n\n  // Top edge\n  for (let i = 1; i < size - 1; i++) edges.push(i);\n\n  // Bottom edge\n  for (let i = 1; i < size - 1; i++) edges.push(size * (size - 1) + i);\n\n  // Left edge\n  for (let i = 1; i < size - 1; i++) edges.push(i * size);\n\n  // Right edge\n  for (let i = 1; i < size - 1; i++) edges.push(i * size + size - 1);\n  return edges;\n}\n\n/**\n * Validate board size\n * @param {number} size - Board size to validate\n * @returns {boolean} True if valid\n */\nexport function isValidBoardSize(size) {\n  const validSizes = [3, 4, 6, 8, 10];\n  return validSizes.includes(size);\n}\n\n/**\n * Get board statistics\n * @param {Array} board - Board state\n * @param {number} size - Board size\n * @returns {Object} Statistics object\n */\nexport function getBoardStatistics(board, size) {\n  return {\n    size,\n    totalTiles: board.length,\n    emptyIndex: board.indexOf(0),\n    progress: calculateProgress(board),\n    minimumMoves: calculateMinimumMoves(board, size),\n    difficulty: getDifficultyRating(calculateMinimumMoves(board, size), size),\n    isSolvable: isSolvable(board, size),\n    isSolved: isSolved(board),\n    inversions: countInversions(board)\n  };\n}","map":{"version":3,"names":["generatePuzzle","size","moves","totalTiles","board","Array","from","length","_","i","emptyIndex","validMoves","getValidMoves","randomMove","Math","floor","random","row","col","push","canMoveTile","tileIndex","indexOf","includes","moveTile","sqrt","newBoard","getMoveDirection","fromIndex","toIndex","diff","isSolved","countInversions","inversions","filteredBoard","filter","tile","j","isSolvable","emptyRow","emptyRowFromBottom","generateSolvablePuzzle","attempts","maxAttempts","move","calculateMinimumMoves","distance","currentRow","currentCol","targetRow","targetCol","abs","getDifficultyRating","minimumMoves","threshold","getHint","bestMove","bestScore","Infinity","moveIndex","testBoard","score","isPerfectGame","moveCount","boardToImageSlices","map","index","x","y","isEmpty","getTileTarget","isTileInPlace","currentIndex","shuffleArray","array","shuffled","createSolvedBoard","cloneBoard","boardsEqual","board1","board2","getAdjacentTiles","adjacent","calculateProgress","correctTiles","round","getCornerTiles","getEdgeTiles","edges","isValidBoardSize","validSizes","getBoardStatistics","progress","difficulty"],"sources":["/home/atlas/puzzle/client/src/utils/puzzleLogic.js"],"sourcesContent":["/**\n * Generate a shuffled puzzle board\n * @param {number} size - Board size (3, 4, 6, 8, or 10)\n * @param {number} moves - Number of random moves to make\n * @returns {Array} Shuffled board state\n */\nexport function generatePuzzle(size, moves = 100) {\n  const totalTiles = size * size;\n  let board = Array.from({ length: totalTiles }, (_, i) => i);\n  let emptyIndex = totalTiles - 1;\n\n  // Make random valid moves to shuffle\n  for (let i = 0; i < moves; i++) {\n    const validMoves = getValidMoves(board, emptyIndex, size);\n    const randomMove =\n      validMoves[Math.floor(Math.random() * validMoves.length)];\n\n    // Swap\n    [board[emptyIndex], board[randomMove]] = [\n      board[randomMove],\n      board[emptyIndex],\n    ];\n    emptyIndex = randomMove;\n  }\n\n  return board;\n}\n\n/**\n * Get valid moves for current board state\n * @param {Array} board - Current board state\n * @param {number} emptyIndex - Index of empty tile\n * @param {number} size - Board size\n * @returns {Array} Array of valid move indices\n */\nexport function getValidMoves(board, emptyIndex, size) {\n  const moves = [];\n  const row = Math.floor(emptyIndex / size);\n  const col = emptyIndex % size;\n\n  // Up\n  if (row > 0) moves.push(emptyIndex - size);\n  // Down\n  if (row < size - 1) moves.push(emptyIndex + size);\n  // Left\n  if (col > 0) moves.push(emptyIndex - 1);\n  // Right\n  if (col < size - 1) moves.push(emptyIndex + 1);\n\n  return moves;\n}\n\n/**\n * Check if a tile can be moved\n * @param {Array} board - Current board state\n * @param {number} tileIndex - Index of tile to move\n * @param {number} size - Board size\n * @returns {boolean}\n */\nexport function canMoveTile(board, tileIndex, size) {\n  const emptyIndex = board.indexOf(0);\n  const validMoves = getValidMoves(board, emptyIndex, size);\n  return validMoves.includes(tileIndex);\n}\n\n/**\n * Move a tile\n * @param {Array} board - Current board state\n * @param {number} tileIndex - Index of tile to move\n * @returns {Array|null} New board state or null if invalid move\n */\nexport function moveTile(board, tileIndex) {\n  const emptyIndex = board.indexOf(0);\n  const size = Math.sqrt(board.length);\n\n  // Check if move is valid (tiles must be adjacent)\n  const validMoves = getValidMoves(board, emptyIndex, size);\n  if (!validMoves.includes(tileIndex)) {\n    return null;\n  }\n\n  // Create new board and swap\n  const newBoard = [...board];\n  [newBoard[emptyIndex], newBoard[tileIndex]] = [\n    newBoard[tileIndex],\n    newBoard[emptyIndex],\n  ];\n\n  return newBoard;\n}\n\n/**\n * Get direction of move\n * @param {number} fromIndex - Starting index\n * @param {number} toIndex - Ending index\n * @param {number} size - Board size\n * @returns {string} Direction ('up', 'down', 'left', 'right')\n */\nexport function getMoveDirection(fromIndex, toIndex, size) {\n  const diff = toIndex - fromIndex;\n\n  if (diff === -size) return \"up\";\n  if (diff === size) return \"down\";\n  if (diff === -1) return \"left\";\n  if (diff === 1) return \"right\";\n\n  return \"unknown\";\n}\n\n/**\n * Check if puzzle is solved\n * @param {Array} board - Current board state\n * @returns {boolean}\n */\nexport function isSolved(board) {\n  for (let i = 0; i < board.length - 1; i++) {\n    if (board[i] !== i) return false;\n  }\n  return board[board.length - 1] === 0;\n}\n\n/**\n * Count inversions for solvability check\n * @param {Array} board - Board state\n * @returns {number} Number of inversions\n */\nexport function countInversions(board) {\n  let inversions = 0;\n  const filteredBoard = board.filter((tile) => tile !== 0);\n\n  for (let i = 0; i < filteredBoard.length - 1; i++) {\n    for (let j = i + 1; j < filteredBoard.length; j++) {\n      if (filteredBoard[i] > filteredBoard[j]) {\n        inversions++;\n      }\n    }\n  }\n\n  return inversions;\n}\n\n/**\n * Check if puzzle is solvable\n * @param {Array} board - Board state\n * @param {number} size - Board size\n * @returns {boolean}\n */\nexport function isSolvable(board, size) {\n  const inversions = countInversions(board);\n  const emptyRow = Math.floor(board.indexOf(0) / size);\n\n  if (size % 2 === 1) {\n    // Odd grid: solvable if inversions is even\n    return inversions % 2 === 0;\n  } else {\n    // Even grid: solvable if (inversions + empty row from bottom) is odd\n    const emptyRowFromBottom = size - emptyRow;\n    return (inversions + emptyRowFromBottom) % 2 === 1;\n  }\n}\n\n/**\n * Generate a guaranteed solvable puzzle\n * @param {number} size - Board size\n * @returns {Array} Solvable board state\n */\nexport function generateSolvablePuzzle(size) {\n  let board;\n  let attempts = 0;\n  const maxAttempts = 100;\n\n  do {\n    board = generatePuzzle(size, size * size * 2);\n    attempts++;\n\n    if (attempts >= maxAttempts) {\n      // Fallback: create solved puzzle and make one legal move\n      board = Array.from({ length: size * size }, (_, i) => i);\n      const emptyIndex = size * size - 1;\n      const validMoves = getValidMoves(board, emptyIndex, size);\n      const move = validMoves[0];\n      [board[emptyIndex], board[move]] = [board[move], board[emptyIndex]];\n      break;\n    }\n  } while (!isSolvable(board, size) || isSolved(board));\n\n  return board;\n}\n\n/**\n * Calculate minimum moves to solve (estimation using Manhattan distance)\n * @param {Array} board - Current board state\n * @param {number} size - Board size\n * @returns {number} Estimated minimum moves\n */\nexport function calculateMinimumMoves(board, size) {\n  let distance = 0;\n\n  for (let i = 0; i < board.length; i++) {\n    const tile = board[i];\n    if (tile === 0) continue;\n\n    const currentRow = Math.floor(i / size);\n    const currentCol = i % size;\n    const targetRow = Math.floor(tile / size);\n    const targetCol = tile % size;\n\n    // Manhattan distance\n    distance +=\n      Math.abs(currentRow - targetRow) + Math.abs(currentCol - targetCol);\n  }\n\n  return distance;\n}\n\n/**\n * Get difficulty rating based on moves required\n * @param {number} minimumMoves - Minimum moves to solve\n * @param {number} size - Board size\n * @returns {string} Difficulty rating\n */\nexport function getDifficultyRating(minimumMoves, size) {\n  const threshold = size * size;\n\n  if (minimumMoves < threshold * 0.5) return \"easy\";\n  if (minimumMoves < threshold * 1) return \"medium\";\n  if (minimumMoves < threshold * 1.5) return \"hard\";\n  return \"expert\";\n}\n\n/**\n * Get hint for next move\n * @param {Array} board - Current board state\n * @param {number} size - Board size\n * @returns {number|null} Index of tile to move, or null\n */\nexport function getHint(board, size) {\n  const emptyIndex = board.indexOf(0);\n  const validMoves = getValidMoves(board, emptyIndex, size);\n\n  // Find move that reduces Manhattan distance the most\n  let bestMove = null;\n  let bestScore = Infinity;\n\n  for (const moveIndex of validMoves) {\n    const testBoard = moveTile(board, moveIndex);\n    if (!testBoard) continue;\n\n    const score = calculateMinimumMoves(testBoard, size);\n\n    if (score < bestScore) {\n      bestScore = score;\n      bestMove = moveIndex;\n    }\n  }\n\n  return bestMove;\n}\n\n/**\n * Check if current solution is optimal\n * @param {number} moveCount - Number of moves taken\n * @param {number} minimumMoves - Minimum possible moves\n * @returns {boolean}\n */\nexport function isPerfectGame(moveCount, minimumMoves) {\n  // Allow small margin for error since minimum is an estimate\n  return moveCount <= minimumMoves * 1.1;\n}\n\n/**\n * Convert board to image slice positions\n * @param {Array} board - Board state\n * @param {number} size - Board size\n * @returns {Array} Array of {x, y, tile} for rendering\n */\nexport function boardToImageSlices(board, size) {\n  return board.map((tile, index) => {\n    const row = Math.floor(index / size);\n    const col = index % size;\n\n    return {\n      tile,\n      x: col,\n      y: row,\n      isEmpty: tile === 0,\n    };\n  });\n}\n\n/**\n * Get tile's target position\n * @param {number} tile - Tile number\n * @param {number} size - Board size\n * @returns {object} {row, col}\n */\nexport function getTileTarget(tile, size) {\n  return {\n    row: Math.floor(tile / size),\n    col: tile % size,\n  };\n}\n\n/**\n * Check if tile is in correct position\n * @param {number} tile - Tile number\n * @param {number} currentIndex - Current position\n * @returns {boolean}\n */\nexport function isTileInPlace(tile, currentIndex) {\n  return tile === currentIndex || tile === 0;\n}\n\n/**\n * Shuffle array using Fisher-Yates algorithm\n * @param {Array} array - Array to shuffle\n * @returns {Array} Shuffled array\n */\nexport function shuffleArray(array) {\n  const shuffled = [...array];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n  }\n  return shuffled;\n}\n\n/**\n * Create solved board\n * @param {number} size - Board size\n * @returns {Array} Solved board state\n */\nexport function createSolvedBoard(size) {\n  return Array.from({ length: size * size }, (_, i) => i);\n}\n\n/**\n * Clone board\n * @param {Array} board - Board to clone\n * @returns {Array} Cloned board\n */\nexport function cloneBoard(board) {\n  return [...board];\n}\n\n/**\n * Compare two boards\n * @param {Array} board1 - First board\n * @param {Array} board2 - Second board\n * @returns {boolean} True if boards are equal\n */\nexport function boardsEqual(board1, board2) {\n  if (board1.length !== board2.length) return false;\n\n  for (let i = 0; i < board1.length; i++) {\n    if (board1[i] !== board2[i]) return false;\n  }\n\n  return true;\n}\n\n/**\n * Get adjacent tiles to a position\n * @param {number} index - Tile index\n * @param {number} size - Board size\n * @returns {Array} Array of adjacent indices\n */\nexport function getAdjacentTiles(index, size) {\n  const row = Math.floor(index / size);\n  const col = index % size;\n  const adjacent = [];\n\n  if (row > 0) adjacent.push(index - size); // Up\n  if (row < size - 1) adjacent.push(index + size); // Down\n  if (col > 0) adjacent.push(index - 1); // Left\n  if (col < size - 1) adjacent.push(index + 1); // Right\n\n  return adjacent;\n}\n\n/**\n * Calculate progress percentage\n * @param {Array} board - Current board\n * @returns {number} Percentage solved (0-100)\n */\nexport function calculateProgress(board) {\n  let correctTiles = 0;\n\n  for (let i = 0; i < board.length - 1; i++) {\n    if (board[i] === i) correctTiles++;\n  }\n\n  return Math.round((correctTiles / (board.length - 1)) * 100);\n}\n\n/**\n * Get all corner tiles\n * @param {number} size - Board size\n * @returns {Array} Array of corner tile indices\n */\nexport function getCornerTiles(size) {\n  return [\n    0, // Top-left\n    size - 1, // Top-right\n    size * (size - 1), // Bottom-left\n    size * size - 1, // Bottom-right (empty space)\n  ];\n}\n\n/**\n * Get all edge tiles (not corners)\n * @param {number} size - Board size\n * @returns {Array} Array of edge tile indices\n */\nexport function getEdgeTiles(size) {\n  const edges = [];\n\n  // Top edge\n  for (let i = 1; i < size - 1; i++) edges.push(i);\n\n  // Bottom edge\n  for (let i = 1; i < size - 1; i++) edges.push(size * (size - 1) + i);\n\n  // Left edge\n  for (let i = 1; i < size - 1; i++) edges.push(i * size);\n\n  // Right edge\n  for (let i = 1; i < size - 1; i++) edges.push(i * size + size - 1);\n\n  return edges;\n}\n\n/**\n * Validate board size\n * @param {number} size - Board size to validate\n * @returns {boolean} True if valid\n */\nexport function isValidBoardSize(size) {\n  const validSizes = [3, 4, 6, 8, 10];\n  return validSizes.includes(size);\n}\n\n/**\n * Get board statistics\n * @param {Array} board - Board state\n * @param {number} size - Board size\n * @returns {Object} Statistics object\n */\nexport function getBoardStatistics(board, size) {\n  return {\n    size,\n    totalTiles: board.length,\n    emptyIndex: board.indexOf(0),\n    progress: calculateProgress(board),\n    minimumMoves: calculateMinimumMoves(board, size),\n    difficulty: getDifficultyRating(calculateMinimumMoves(board, size), size),\n    isSolvable: isSolvable(board, size),\n    isSolved: isSolved(board),\n    inversions: countInversions(board),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}